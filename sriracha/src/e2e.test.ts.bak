import 'fake-indexeddb/auto';

import { nullifierBufferToIndex } from 'barretenberg/client_proofs/join_split_proof';
import { HashPath } from 'barretenberg/merkle_tree';
import { BarretenbergWasm } from 'barretenberg/wasm';
import { EventEmitter } from 'events';
import request from 'supertest';
import Server from './server';

import { WorldStateDb } from './world_state_db';

EventEmitter.defaultMaxListeners = 30;

import { Blake2s } from 'barretenberg/crypto/blake2s';
import { appFactory } from './api';

function convertToHashPath(nullifierPath: [][]): HashPath {
  const nullifierPathBufArray = nullifierPath.map((entry: object[]) => {
    return [Buffer.from(entry[0]), Buffer.from(entry[1])];
  });

  return new HashPath(nullifierPathBufArray);
}

const getNulliferHex = async () => {
  const barretenberg = await BarretenbergWasm.new();
  const blake2s = new Blake2s(barretenberg);
  const nullifierBigInt = BigInt(Math.floor(Math.random() * 1000000)).toString(10);
  const nullifierBuf = Buffer.from(nullifierBigInt);
  const nullifierHash = blake2s.hashToField(new Uint8Array(nullifierBuf));
  return `0x${nullifierBufferToIndex(Buffer.from(nullifierHash)).toString(16)}`;
};

describe('real server', () => {
  // TODO  we should get this working
  let api: any;
  let server: Server;

  beforeEach(async () => {
    server = new Server(new WorldStateDb());

    await server.start();
    const app = appFactory(server, '/api');
    api = app.listen(8080);
  });

  afterEach(async () => {
    await server.stop();

    await api.close();
  });

  it('should return a hash path of 128 length', async () => {
    const nullifier1Hex = await getNulliferHex();
    const nullifier2Hex = await getNulliferHex();
    const res = await (request(api) as any).get(`/api/getSequentialPaths/${nullifier1Hex}/${nullifier2Hex}`);
    expect(res.body).toHaveProperty('oldRoot');
    expect(res.body).toHaveProperty('hashPaths.old');
    expect(res.body).toHaveProperty('hashPaths.new');
    expect(res.body).toHaveProperty('roots');

    expect(res.body.hashPaths.old).toHaveLength(2);
    expect(res.body.hashPaths.new).toHaveLength(2);
    expect(res.body.hashPaths.old[0].data).toHaveLength(128);
    expect(res.body.hashPaths.old[1].data).toHaveLength(128);
    expect(res.body.hashPaths.new[0].data).toHaveLength(128);
    expect(res.body.hashPaths.new[1].data).toHaveLength(128);
  });

  it('should be able to format hashPaths correctly', async () => {
    const nullifier1Hex = await getNulliferHex();
    const nullifier2Hex = await getNulliferHex();
    const res = await (request(api) as any).get(`/api/getSequentialPaths/${nullifier1Hex}/${nullifier2Hex}`);
    const { hashPaths } = res.body;
    const currentNullifierPaths = hashPaths.old; // this is the old set of hashPath, should
    const currentNullifierHashPath1 = convertToHashPath(currentNullifierPaths[0].data);

    const currentNullifierHashPath1Buf = currentNullifierHashPath1.toBuffer();
    expect(currentNullifierHashPath1Buf.length).toBeGreaterThan(0);

    const hashPathRes = await (request(api) as any).get(`/api/getHashPath/${nullifier1Hex}`);
    const { hashPath } = hashPathRes.body;
    const realHashPath = convertToHashPath(hashPath.data);
    const realHashPathBuf = realHashPath.toBuffer();
    expect(realHashPathBuf.length).toBeGreaterThan(0);
  });

  it('should ')

  // TODO we should get this working
  // it('the returned old hash  paths should be sequential', async () => {
  //   const barretenberg = await BarretenbergWasm.new();

  //   const nullifier1Hex = await getNulliferHex();
  //   const nullifier2Hex = await getNulliferHex();
  //   const nullifier1Binary = BigInt(nullifier1Hex).toString(2);
  //   const nullifier2Binary = BigInt(nullifier2Hex).toString(2);

  //   const res = await (<any>request(api))['get'](`/api/getSequentialPaths/${nullifier1Hex}/${nullifier2Hex}`);
  //   const { hashPaths } = res.body;
  //   const { old, new: newArray } = hashPaths;
  //   const last = hashPaths.old[0].data[hashPaths.old[0].data.length - 1];
  //   const next = hashPaths.new[0].data[hashPaths.new[0].data.length - 1];
  //   const pedersen = new Pedersen(barretenberg);
  //   const oldNullifierRootHash = pedersen.compress(new Uint8Array(last[0].data), new Uint8Array(last[1].data));
  //   const newNullifierRootHash = pedersen.compress(new Uint8Array(next[0].data), new Uint8Array(next[1].data));

  //   expect(oldNullifierRootHash).not.toEqual(newNullifierRootHash);

  //   let counter = 0;

    // we need to check that the tree is identical EXCEPT the one hash path that has changed due to insertion of nullifier 1
    // this will be the case if the non changed side is the same in two hash paths -
    // how do we find which side has changed?z
    // binary is base 2
    //                []
    //       []               [x]  0
    //   []       []       [x]     [] 1
    // [][]     [][]     [x][]  [][] 1

    // 001 == 1
    // 010 == 2
    // 011 == 3
    // 100 == 4
    // 101 == 5
    // 110 == 6

    // const nullifier1 = nullifier1BigInt;
    // console.log(nullifier1Binary);
    // const reverseNul1 = nullifier1Binary.split('').reverse().join('');
    // console.log(reverseNul1);
    // // const reverseNul2 = nullifier1Binary.split('').reverse().join('');

    // const treeDepth = 128;
    // for (let i = 0; i < treeDepth; ++i) {
    //   const path_bit = Number(reverseNul1[i] || 0);

    //   const isLeftSame =
    //     Buffer.from(old[0].data[i][0].data).toString('hex') == Buffer.from(newArray[0].data[i][0].data).toString('hex');
    //   const share_left = Number(isLeftSame) & Number(path_bit);
    //   const isRightSame =
    //     Buffer.from(old[0].data[i][1].data).toString('hex') == Buffer.from(newArray[0].data[i][1].data).toString('hex');
    //   const share_right = Number(isRightSame) & Number(!path_bit);
    //   const xor = Number(share_left) ^ Number(share_right);
    //   if (!xor) {
    //     console.log({ i, isLeftSame, isRightSame, share_left, share_right, path_bit, xor, nullifier1Binary });
    //   }
    //   expect(xor).toEqual(1);
    // }
    // expect(counter).toEqual(1);
    // counter = 0;
    // for (let i = 0; i < treeDepth; ++i) {
    //   const path_bit = Number(nullifier2Binary[treeDepth - i - 1] || 0);
    //   const isLeftSame =
    //     Buffer.from(old[1].data[i][0].data).toString('hex') ==
    //     Buffer.from(newArray[1].data[i][0].data).toString('hex');
    //   const share_left = Number(isLeftSame) & Number(path_bit);
    //   const isRightSame =
    //     Buffer.from(old[1].data[i][1].data).toString('hex') ==
    //     Buffer.from(newArray[1].data[i][1].data).toString('hex');
    //   const share_right = Number(isRightSame) & Number(!path_bit);
    //   const xor = Number(share_left) ^ Number(share_right);
    //   if (!xor) {
    //     console.log({ i, isLeftSame, isRightSame, share_left, share_right, path_bit, xor, nullifier2Binary });
    //   }
    //   expect(xor).toEqual(1);
    // }
  });
});
